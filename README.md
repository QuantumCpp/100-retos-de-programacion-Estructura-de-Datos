# üöÄ 100 Retos de Programaci√≥n: Estructuras de Datos

Una colecci√≥n completa de desaf√≠os de programaci√≥n organizados por niveles de dificultad, desde estructuras de datos medias hasta super avanzadas, con la finalidad de realizar un reto cada dia.

---

## üìö Tabla de Contenidos

- [Nivel Medio (1-35)](#nivel-medio-1-35)
  - [√Årboles y Grafos B√°sicos](#√°rboles-y-grafos-b√°sicos)
  - [Heaps y Colas de Prioridad](#heaps-y-colas-de-prioridad)
  - [Hash Tables y Mapas](#hash-tables-y-mapas)
  - [Estructuras Especializadas](#estructuras-especializadas)
  - [Problemas de Aplicaci√≥n](#problemas-de-aplicaci√≥n)
- [Nivel Avanzado (36-70)](#nivel-avanzado-36-70)
  - [√Årboles Avanzados](#√°rboles-avanzados)
  - [Grafos Complejos](#grafos-complejos)
  - [Estructuras Persistentes](#estructuras-persistentes)
  - [Estructuras Probabil√≠sticas](#estructuras-probabil√≠sticas)
  - [Problemas Complejos](#problemas-complejos)
- [Nivel Super Avanzado (71-100)](#nivel-super-avanzado-71-100)
  - [Estructuras Concurrentes](#estructuras-concurrentes)
  - [Estructuras Comprimidas](#estructuras-comprimidas)
  - [Geometr√≠a Computacional](#geometr√≠a-computacional)
  - [Estructuras para Big Data](#estructuras-para-big-data)
  - [Problemas Extremos](#problemas-extremos)
- [Gu√≠a de Uso](#gu√≠a-de-uso)
- [Contribuir](#contribuir)

---

## üü¢ Nivel Medio (1-35)

### √Årboles y Grafos B√°sicos

1. **√Årbol Binario de B√∫squeda (BST)**  
   Implementar un √°rbol binario de b√∫squeda con operaciones de inserci√≥n, eliminaci√≥n y b√∫squeda

2. **Ancestro Com√∫n M√°s Bajo (LCA)**  
   Encontrar el ancestro com√∫n m√°s bajo de dos nodos en un √°rbol binario

3. **Validar BST**  
   Verificar si un √°rbol binario es un √°rbol de b√∫squeda binario v√°lido

4. **Recorridos Iterativos**  
   Realizar recorridos en √°rbol (inorden, preorden, postorden) de forma iterativa

5. **Di√°metro de √Årbol**  
   Encontrar el di√°metro de un √°rbol binario

6. **√Årbol AVL**  
   Implementar un √°rbol AVL con rotaciones autom√°ticas

7. **Detecci√≥n de Ciclos**  
   Detectar ciclos en un grafo dirigido usando DFS

8. **BFS y DFS**  
   Implementar b√∫squeda en anchura (BFS) y profundidad (DFS) en grafos

9. **Todos los Caminos**  
   Encontrar todos los caminos de un grafo desde un nodo origen a un destino

10. **Serializaci√≥n de √Årbol**  
    Serializar y deserializar un √°rbol binario

### Heaps y Colas de Prioridad

11. **Heap M√≠nimo**  
    Implementar un heap m√≠nimo desde cero

12. **K Elementos M√°s Grandes**  
    Encontrar los K elementos m√°s grandes en un array usando un heap

13. **Fusionar K Listas**  
    Fusionar K listas ordenadas usando una cola de prioridad

14. **Mediana M√≥vil**  
    Implementar una mediana m√≥vil usando dos heaps

15. **Sistema de Scheduling**  
    Dise√±ar un sistema de scheduling con prioridades usando heap

### Hash Tables y Mapas

16. **Tabla Hash Personalizada**  
    Implementar una tabla hash con manejo de colisiones por encadenamiento

17. **Cach√© LRU**  
    Dise√±ar un cach√© LRU (Least Recently Used)

18. **Primer Car√°cter √önico**  
    Encontrar el primer car√°cter no repetido en un stream de caracteres

19. **Agrupar Anagramas**  
    Agrupar anagramas usando hash maps

20. **Trie para Autocompletado**  
    Implementar un sistema de autocompletado con Trie

### Estructuras Especializadas

21. **Pila con Min**  
    Implementar una pila que soporte getMin() en O(1)

22. **Cola con Pilas**  
    Dise√±ar una cola usando dos pilas

23. **Deque**  
    Implementar un deque (cola de doble extremo)

24. **Rangos de Tiempo**  
    Crear una estructura de datos para manejar rangos de tiempo solapados

25. **Skip List**  
    Implementar Skip List para b√∫squeda r√°pida

### Problemas de Aplicaci√≥n

26. **Historial de Navegador**  
    Dise√±ar un sistema de historial de navegador (back/forward)

27. **Evaluador de Expresiones**  
    Implementar un evaluador de expresiones con par√©ntesis

28. **Par√©ntesis Balanceados**  
    Crear un sistema de validaci√≥n de par√©ntesis balanceados

29. **B√∫squeda en Rangos**  
    Dise√±ar una estructura para encontrar rangos que contienen un valor

30. **Union-Find B√°sico**  
    Implementar Union-Find (Disjoint Set) b√°sico

31. **Componentes Conexos**  
    Encontrar componentes conexos en un grafo no dirigido

32. **√Årbol de Segmentos**  
    Implementar un √°rbol de segmentos para consultas de suma en rangos

33. **Range Minimum Query**  
    Dise√±ar una estructura para consultas de rango m√≠nimo (RMQ)

34. **Fenwick Tree**  
    Implementar un Fenwick Tree (Binary Indexed Tree)

35. **Sistema de Reservaciones**  
    Crear un sistema de reservaciones con verificaci√≥n de disponibilidad

---

## üü° Nivel Avanzado (36-70)

### √Årboles Avanzados

36. **√Årbol Rojo-Negro**  
    Implementar un √°rbol Rojo-Negro con todas sus operaciones

37. **√Årbol de Sufijos**  
    Construir un √°rbol de sufijos para b√∫squeda de patrones

38. **Splay Tree**  
    Implementar un Splay Tree con operaciones de splice

39. **√Årbol B**  
    Dise√±ar un √°rbol B para sistemas de bases de datos

40. **Van Emde Boas Tree**  
    Implementar un √°rbol de Van Emde Boas para enteros

41. **√Årbol de Intervalos**  
    Crear un √°rbol de intervalos para consultas de solapamiento

42. **Treap**  
    Implementar un Treap (√°rbol + heap h√≠brido)

43. **K-D Tree**  
    Dise√±ar un √°rbol k-d para b√∫squedas espaciales multidimensionales

44. **R-Tree**  
    Implementar un √°rbol R para indexaci√≥n espacial

45. **√Årbol de Merkle**  
    Crear un √°rbol de Merkle para verificaci√≥n de integridad

### Grafos Complejos

46. **Dijkstra**  
    Implementar el algoritmo de Dijkstra para caminos m√°s cortos

47. **Bellman-Ford**  
    Algoritmo de Bellman-Ford para grafos con pesos negativos

48. **Floyd-Warshall**  
    Implementar Floyd-Warshall para todos los pares de caminos m√°s cortos

49. **Componentes Fuertemente Conexos**  
    Encontrar componentes fuertemente conexos (algoritmo de Tarjan)

50. **Algoritmo de Prim**  
    Implementar el algoritmo de Prim para √°rbol de expansi√≥n m√≠nima

51. **Algoritmo de Kruskal**  
    Algoritmo de Kruskal con Union-Find optimizado

52. **Puentes y Puntos de Articulaci√≥n**  
    Detectar puentes y puntos de articulaci√≥n en grafos

53. **Flujo M√°ximo**  
    Implementar flujo m√°ximo (algoritmo de Ford-Fulkerson)

54. **Emparejamiento Bipartito**  
    Resolver el problema de emparejamiento bipartito (algoritmo h√∫ngaro)

55. **A* Pathfinding**  
    Implementar algoritmo A* para pathfinding

### Estructuras Persistentes

56. **Lista Enlazada Persistente**  
    Implementar una lista enlazada persistente (inmutable)

57. **BST Persistente**  
    Crear un √°rbol binario de b√∫squeda persistente

58. **Hash Map Persistente**  
    Dise√±ar un hash map persistente usando HAMT

59. **Cola Persistente**  
    Implementar una cola persistente con complejidad amortizada

60. **Vector Persistente**  
    Crear un vector persistente estilo Clojure

### Estructuras Probabil√≠sticas

61. **Bloom Filter**  
    Implementar un Bloom Filter para test de pertenencia

62. **Count-Min Sketch**  
    Dise√±ar un Count-Min Sketch para frecuencias aproximadas

63. **HyperLogLog**  
    Crear un HyperLogLog para cardinalidad aproximada

64. **Filtro de Cuckoo**  
    Implementar un filtro de Cuckoo con m√∫ltiples funciones hash

65. **Skip Graph**  
    Dise√±ar una estructura Skip Graph para redes P2P

### Problemas Complejos

66. **Sistema de Versionado**  
    Implementar un sistema de versionado de documentos con diff eficiente

67. **K-√©simo Elemento Din√°mico**  
    Dise√±ar una estructura para consultas de k-√©simo elemento m√°s peque√±o din√°mico

68. **√çndice Invertido**  
    Crear un √≠ndice invertido para motor de b√∫squeda

69. **Rope**  
    Implementar un rope para manipulaci√≥n eficiente de strings largos

70. **Autocompletado con Ranking**  
    Dise√±ar una estructura de datos para autocompletado con ranking

---

## üî¥ Nivel Super Avanzado (71-100)

### Estructuras Concurrentes

71. **Hash Map Lock-Free**  
    Implementar un hash map lock-free usando CAS

72. **Cola Concurrente**  
    Dise√±ar una cola concurrente sin bloqueos (lock-free queue)

73. **Skip List Concurrente**  
    Crear un skip list concurrente thread-safe

74. **√Årbol B+ Concurrente**  
    Implementar un √°rbol B+ concurrente para bases de datos

75. **Pool de Memoria Lock-Free**  
    Dise√±ar un pool de memoria lock-free

### Estructuras Comprimidas

76. **Wavelet Tree**  
    Implementar un wavelet tree para consultas en secuencias

77. **FM-Index**  
    Crear una estructura de datos FM-Index para b√∫squeda comprimida

78. **Succinct Tree**  
    Dise√±ar un Succinct Tree para representaci√≥n compacta de √°rboles

79. **Rank/Select**  
    Implementar Rank/Select sobre bitvectors comprimidos

80. **Patricia Trie**  
    Crear un Patricia Trie comprimido (Radix Tree)

### Geometr√≠a Computacional

81. **√Årbol de Segmentos 2D**  
    Implementar un √°rbol de segmentos 2D para consultas rectangulares

82. **Punto M√°s Cercano**  
    Dise√±ar una estructura para punto m√°s cercano en espacio 2D/3D

83. **L√≠nea de Barrido**  
    Implementar un algoritmo de l√≠nea de barrido con eventos

84. **Rango Ortogonal**  
    Crear una estructura para consultas de rango ortogonal

85. **Quadtree/Octree**  
    Dise√±ar un Quadtree/Octree para particionamiento espacial

### Estructuras para Big Data

86. **LSM-Tree**  
    Implementar un LSM-Tree para sistemas de almacenamiento

87. **B-epsilon Tree**  
    Dise√±ar un B-epsilon tree para inserciones masivas

88. **Quantiles Aproximados**  
    Crear una estructura de streaming para quantiles aproximados

89. **Tango Tree**  
    Implementar un Tango Tree para b√∫squedas √≥ptimas

90. **Estructura Cache-Oblivious**  
    Dise√±ar una estructura cache-oblivious para memoria externa

### Problemas Extremos

91. **Suffix Array Lineal**  
    Implementar un Suffix Array con construcci√≥n en tiempo linear

92. **Y-fast Trie**  
    Crear una estructura Y-fast trie para predecesor/sucesor en O(log log n)

93. **Dynamic Connectivity**  
    Dise√±ar un Dynamic Connectivity con link-cut trees

94. **Range Tree Multidimensional**  
    Implementar un Range Tree multidimensional con fraccional cascading

95. **LCA en O(1)**  
    Crear una estructura para LCA con preprocesamiento O(n) y query O(1)

96. **Splay Tree con An√°lisis**  
    Implementar un Splay Tree con an√°lisis amortizado completo

97. **Fusion Tree**  
    Dise√±ar un Fusion Tree para ordenamiento en tiempo sublineal

98. **Estructura Kinetic**  
    Crear una estructura Kinetic para datos en movimiento

99. **Estructura Retroactiva**  
    Implementar una estructura de datos retroactiva (retroactive data structure)

100. **Base de Datos en Memoria**  
     Dise√±ar un sistema completo de base de datos en memoria con √≠ndices m√∫ltiples, transacciones ACID y recuperaci√≥n ante fallos
---
## ü§ù Contribuir

Si deseas agregar m√°s retos o mejorar los existentes:

1. Fork este repositorio
2. Crea una rama con tu feature (`git checkout -b feature/nuevo-reto`)
3. Commit tus cambios (`git commit -m 'A√±ade nuevo reto'`)
4. Push a la rama (`git push origin feature/nuevo-reto`)
5. Abre un Pull Request

---

## üìù Licencia
Este proyecto est√° bajo la licencia MIT. Si√©ntete libre de usar, modificar y distribuir este contenido.
---
## ‚≠ê Agradecimientos
Gracias a la comunidad de programadores que constantemente busca mejorar sus habilidades y compartir conocimiento.
**¬°Feliz coding! üíªüöÄ**
